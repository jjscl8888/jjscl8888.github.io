<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[类与类之间关系]]></title>
    <url>%2F2018%2F07%2F27%2F%E7%B1%BB%E4%B8%8E%E7%B1%BB%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[1 继承一个类继承另一个类的功能 2 实现一个类实现接口的功能 3依赖一个类使用另一个类 4关联强的依赖关系（包含） 5 聚合是关联关系一种特例，它体现整体以部分关系（可分离） 组合组合是关联一种特例强聚合，表现为整体与部分关系（但是必可分离）]]></content>
  </entry>
  <entry>
    <title><![CDATA[面向对象设计原则]]></title>
    <url>%2F2018%2F07%2F25%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[1 依赖倒置原则 2 开放封闭原则1、扩展开放，对更改封闭。 2、类模块应该是可扩展的，但是不可修改。 3 单一职责原则1、一个类应该仅有一个引起他变化的原因 2、变化的方向隐含着类的责任 4 替换原则1、子类必须能够替换他们的基类 2、继承表达类型抽象 5 接口隔离原则1、不应该强迫客户程序依赖他们不用的方法 2、接口应该小而完备 6 优先使用对象组合，而不是类继承7 封装变化点8 针对接口编程，而不是针对实现编程 模式 1）组件模式–通过晚期绑定，来实现框架与应用程序之间的松耦合，是二者之间协作时常用模式。1）template mode（多线程） 基类已经定义好框架，且调用虚函数，而由子类去实现。不同子类实现不同行为。 2）策略模式 3）观察者模式 2）“单一职责”模式： 1）装饰模式注意 2）桥接模式 3）对象创建模式 1)工厂模式2）抽象工厂强调一系列对象之间有相关性。3）原型模式4）构建器 4）对象性能模式AA1）单例模式双检查锁设计—由于读写reorder不安全（出问题）instance=new Singleton();执行包含三步：1）分配内存；2）构造函数；3）赋值但是由于cpu可能导致2）和3）步聚相反，导致instance不为null，由此出现问题。2）享元模式举例子：字体类型。 5 接口隔离模式1） 门面模式2）代理模式3）适配器模式适配器继承新的接口，且包含旧的接口4）中介者模式 6 状态变化模式1）状态模式和策略模式很相似。2）备忘录模式 6 数据结构模式1）组合模式2）迭代器模式迭代器模式里面含有要遍历的对象，而这个对象类可以返回迭代器类3）职责链模式 行为变化模式1）命令模式2）访问者模式 8 领域规则解释器模式]]></content>
  </entry>
  <entry>
    <title><![CDATA[诺瓦]]></title>
    <url>%2F2018%2F07%2F22%2F%E8%AF%BA%E7%93%A6%2F</url>
    <content type="text"><![CDATA[提前批 1）c++1、指针与引用区别 2、常量指针与指针常量区别 3、struct和class区别，初始化可以在类后面加｛｝初始化? 唯一区别在于struct为public,而class默认为private,可以但是需要申明为public 4、纯虚函数与虚函数区别 主要抽象类不能申明对象，继承的类实现了该纯虚函数，才能申明对象，否则该子类也为抽象类，也不能申明对象。 5 、 进程同步方法 临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问 互斥量：为协调共同对一个共享资源的单独访问而设计 信号量：为控制一个具有有限数量用户资源而设计 事件：用来通知线程有一些事件已发生，从而启动后续继任务的开始。 6、进程通信方法？ 管道、消息队列、共享内存、信号量、socket 7、i++是否是原子操作 i++操作分为三个阶段（读、写、改），且三个阶段可以被中断。 内存到寄存器-》寄存器递增-》写回内存 2)mysql1)创建一个表 2）如何快速找到想要的数据---索引 3）计算机网络1）为什么要四次分手 为了使得另一方数据发送完 2）大端口和小端口，怎么写程序判断？ 3）http1.1 和http2.0区别？ 4）项目1）爬虫下载大的文件方法？ 2）如何保存消息--很大时候？ 3）当发送大的字符串时候该怎么解决？ 分段传输，设定每次最大传输字符数，直到传输完全。 4）项目中注意哪些问题？ 5）算法1）判断一个链表是否有环 2）给定字串判断是否是ipv4？ 6）笔试题目也问。1）大文件排序问题 7）总结1）进程同步方式1.临界区2、互斥量3、信号量4、事件5、总结 2)大端与小端1、大端：高字节存储在低地址中2、小端：低字节存储在低字节0x12345678–32位大端（0x12345678）小端（0x78563412）3、代码 3）http1.1与http2.0区别1、2.0采用二进制格式而非文本格式2、2.0完全多路复用3、2.0使用报头压缩，降低开销4、2.0让服务器可以响应主动“推送”到客户端缓存中 4）大文件排序问题1、分治法 1）分割大文件--小文件 2）排序--对小文件排序（快排） 3）合并--得到有序大文件 5）top K]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F07%2F19%2FOpenCV%2F</url>
    <content type="text"><![CDATA[Evernote Export body, td { font-family: 微软雅黑; font-size: 12pt; } 1.1Opencv周边概念认知 创建时间：2017/10/19 8:52 更新时间：2017/10/19 10:08 作者：2568349595@qq.com 1.1Opencv周边概念认知1.图像处理：着重于处理图像（增强、还原、去噪、分割）2.机器视觉：使用计算机模拟人的视觉 opencv是一个基于开源开发的跨平台计算机视觉库，它实现了图像处理和计算机视觉方面的很多通用算法。主要解决如下领域的问题：人机交互物体识别图像分区人脸识别动作识别运动跟踪机器人1.2基本框架分析1.3 Opencv 配置opencv_ml249d.libopencv_calib3d249d.libopencv_contrib249d.libopencv_core249d.libopencv_features2d249d.libopencv_flann249d.libopencv_gpu249d.libopencv_highgui249d.libopencv_imgproc249d.libopencv_legacy249d.libopencv_objdetect249d.libopencv_ts249d.libopencv_video249d.libopencv_nonfree249d.libopencv_ocl249d.libopencv_photo249d.libopencv_stitching249d.libopencv_superres249d.libopencv_videostab249d.libopencv_objdetect249.libopencv_ts249.libopencv_video249.libopencv_nonfree249.libopencv_ocl249.libopencv_photo249.libopencv_stitching249.libopencv_superres249.libopencv_videostab249.libopencv_calib3d249.libopencv_contrib249.libopencv_core249.libopencv_features2d249.libopencv_flann249.libopencv_gpu249.libopencv_highgui249.libopencv_imgproc249.libopencv_legacy249.libopencv_ml249.lib1.4图像简单操作1.显示图像2.图像腐蚀3.图象模糊4.canny边缘检测分析：载入图像，并将其转换成灰度图，再用blur函数进行图像模糊进行去噪，然后用canny函数进行边缘检测1.5视频简单操作1.读取并播放视频2.点用摄像头采集头像分析：只需将VideoCapture(0)这个函数里面参数为0即可 2.1 创建时间：2017/10/19 10:16 更新时间：2017/10/19 10:40 作者：2568349595@qq.com 2.1彩色目标跟踪 Camshift光流 optical flow点追踪 ikdemo人脸识别 objectDetection2.2使用CMake生成OpenCV源代码工程的解决方案2.3 “opencv2/opencv.hpp”头文件认知2.6 格式输出函数 3.1.图像的载入、显示和输出到文件 创建时间：2017/10/20 11:24 更新时间：2017/11/17 10:05 作者：2568349595@qq.com 3.1.图像的载入、显示和输出到文件1.命名空间 （1）using namespace cv; (2)在每个类和函数前加上cv::2.Mat类（保存图像和矩阵数据） 默认尺寸为0；也可以指定大小 eg: Mat srcImage=imread(&quot;**.jpg&quot;);3.图像的载入：imread()函数注意：4.图像显示：imshow函数 用于指定的窗口显示一幅图像5.创建窗口：namedWindow()函数6.输出图像到文件中：imwrite()函数2.创建滑动条：createTrackbar()函数原型：2.获得当前轨迹条的位置：getTrackbarPos()函数3.鼠标操作4.本章小结 一.基本图像容器Mat 创建时间：2017/11/17 10:06 更新时间：2017/11/17 11:24 作者：2568349595@qq.com 一.基本图像容器Mat1.Mat 结构的使用(1)Mat类组成： 矩阵头（矩阵大小、存储方法、存储地址）+一个指向存储所有像素值的矩阵（2）拷贝构造函数和赋值运算符 只复制信息头和矩阵指针，而不复制矩阵（3）创建只引用部分数据的信息头（4）释放矩阵 当矩阵的引用计算为0时，自动释放（5）如果想要赋值矩阵（包括信息头和矩阵指针）使用clone()和copyTo()函数2.像素值的存储方法 （1）存储像素值需要指定颜色空间和数据类型 3.显示创建Mat对象的七种方法（可用&lt;&lt;输出二维矩阵数据） （1）使用Mat的构造函数 第三个参数格式（Scalar 为short类型向量，表示颜色信息） （2）在C\C++中通过构造函数初始化 这是一个三维矩阵 （3）为已经存在的lpllmage指针创建信息头 （4）使用Create()函数 （5）使用Matlab式的初始化方式 （6）对小矩阵使用逗号分隔式初始化 （7）为已经存在的对象创建新的信息头 3.格式输出方法 （1）默认风格（使用&lt;&lt;输出） （2）python的风格 （3）逗号分隔风格 （4）Numpy风格和C语言风、 4.输出其他常用数据结构 （1）定义和输出二维点 （2）定义和输出三维点 （3）定义和输出基于Mat的std::vector （4）定义和输出std::vector点 二、常用数据结构和函数1.点的表示：Point类 2.颜色的表示：Scalar类 Scalar表示具有4个元素的数组。3.尺寸的表示：Size类4.矩阵的表示：Rect类 交集和并集格式如下： 平移和释放 5.颜色空间转换：cvtColor()函数（实现RGB向HSV.HSI颜色空间转换，也可以转换为灰度图） 注意：默认存储顺序为BGR6.其他知识点： 三、基本图形绘制​1.DrawEllipse()函数的写法 2​.DrawFilledCircle()函数的写法3.DrawPolygon()函数的写法4.Drawline函数的写法 一.访问图像中的像素 创建时间：2017/11/17 14:31 更新时间：2017/11/17 18:41 作者：2568349595@qq.com 一.访问图像中的像素1.图像在内存中存储方式 （1）灰度图 2.颜色空间缩减 （1）遍历图像矩阵的每一个像素 （2）对像素应用上述公式3.LUT函数：Look up table操作 在Opencv中建议使用一个原型函数来操作 4.计时函数（getTickCount()和getTickFrency()） 5.访问图像中像素的三类方法 （1）指针访问：[]（速度最快） （2）用迭代器操作像素 （3）动态地址计算 注意：at&lt;类型&gt;（int x,int y）可以用来存储图像元素。一定要保证数据类型和矩阵类型相符合。 二.ROI区域图像叠加&amp;图像混合1.感兴趣区域：ROI (1)使用Rect矩形区域 （2）使用Range() 2.线性混合操作 是一种典型的二元的像素操作，它的理论公式为实现两幅画按照某种比列叠加实现3.计算数组加权和：addWeighted()函数 表示为：三、分离颜色通道、多通道图像混合1.通道分离：split()函数 将一个多通道数组分离成几个单通道数组 2.通道融合：merge()函数 四、图像对比度、亮度值调整​1.理论依据 点操作：仅仅根据输入像素值来计算相应的输出像素值 两种常用的点操作是乘上一个常数（对应对比度的调节）以及加上一个常数（亮度调节） g(x)=a*f(x)+b 注意：五、离散傅里叶变换​1.离散傅里叶变换原理 原图=（实数图+虚图）=（幅度图+相位图） 高频代表图像的细节、纹理信息；低频代表图像轮廓信息 用途：图像增强、去噪、图像分割、边缘检测、特征提取、图像压缩2.dft()函数 对一位或者二维浮点数进行正向或者反向离散傅里叶变换​3.返回DFT最优尺寸大小：getOptimalDFTSize()函数4.扩充图像边界：copyMakeBorder()函数5.计算二维矢量的赋值：magnitude()函数​6.计算自然对数：log()函数7.矩阵归一化：normalize()函数六、输入输出XML和YAML文件​1.FileStorage类操作文件的使用引导 ​（1）准备文件写和读操作​ （2）进行文件读写操作 文本和数字的输入和输出 Opencv数据结构输入和输出​ vector和maps的输入和输出 （3）文件关闭本章小结 1.线性滤波：方框滤波、均值滤波、高斯滤波 创建时间：2017/11/18 10:25 更新时间：2017/11/19 9:48 作者：2568349595@qq.com 1.线性滤波：方框滤波、均值滤波、高斯滤波1.平滑处理（模糊处理） 用于减少图像上噪点或者失真（涉及降低图像分辨率）2.图像滤波与滤波器 指在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制 消除图像中的噪声成分叫做图像的平滑化 （1）图像滤波目的：抽出图像特征作为图像识别的特征模式；适应图像处理要求，消除噪声 （2）平滑滤波目的：模糊；消除噪声 （3）空间域的平滑滤波一般采用简单平均法进行，就是求相邻像元点平均亮度值（和领域大小相关） （4）滤波器 （5）Opencv中有： 方框滤波----BoxBlur函数 均值滤波----Blur函数 高斯滤波----GaussianBlur函数 中值滤波----medianBlur函数 双边滤波----bilateralFilter函数3.线性滤波器的简介 线性滤波器：用于剔除输入信号中不想要的频率或者从许多频率中选择一个想要的 4.滤波和模糊5.领域算子与线性领域滤波 （1）领域算子：利用给定像素周围的像素值决定此像素的最终输出值的一种算子 用于局部色调调整、图像滤波、增强、去噪 （2）线性领域算子：一种常用的领域算子，像素的输出取决于输入像素的加权和 （3）常用线性滤波函数 6.方框滤波--boxblur函数 归一化：将要处理的数据缩放到一个范围内（0，1）。均值滤波是方框滤波归一化的特殊情况7.均值滤波：blur函数 （1）均值滤波理论简介 （2）缺点：不能很好的保留图像的细节，使得图像模糊，不能很好的除去噪声 （3）函数原型 8.高斯滤波 （1）理论简介 高斯滤波是一种线性平滑滤波，可以消除高斯噪声，广泛用于图像处理减噪过程。 具体操作： 用一个模板扫描图像中的每一个像素，用模板确定的领域内像素的加权平均灰度值代替模板中心像素点的值 （2）GaussianBlur函数 用来模糊一张图片 二、非线性滤波：中值滤波、双边滤波1.中值滤波：medianBlur函数 基本思想：用像素点领域灰度值的中值代替该像素点的灰度值（除去脉冲噪声、椒盐噪声） 优点：克服图像细节模糊，对于脉冲干扰以及图像扫描噪声有效，也常用于保护边缘信息 （1）具体步聚 2.双边滤波： 结合图像的空间邻近度和像素值相似度一种折中处理，同时考虑空域信息和灰度相似性 （1）优点：可以做到边缘保存 三、形态学滤波：腐蚀与膨胀1.形态学概述： 数学形态学是一门建立在格伦和拓扑学基础之上的图像分析学。基本运算：二值腐蚀和膨胀、二值开闭运算、骨架抽取，极限腐蚀、击中击不中变换、形态学梯度、Top-hat变换、颗粒分析、流域变换、灰度腐蚀和膨胀、灰度开闭运算。灰度值形态学梯度。 膨胀和腐蚀功能：（对图像中高亮部分进行的操作） （1）消除噪声 （2）分割出独立的图像元素，在图像中连接相邻的元素 （3）寻找图像中的明显的极大值区域或极小值区域 （4）求出图像的梯度2.膨胀： 膨胀就是求局部最大值的操作；3.腐蚀： 求局部最小值的操作四、形态学滤波：开运算、闭运算、形态学梯度、顶帽、黑帽1.开运算： 就是先腐蚀后膨胀的过程 （1）作用：消除小物体，并且在平滑大物体时边界不明显改变其面积2.闭运算： 先膨胀后腐蚀的过程 (1)作用：能够排除小型黑洞（黑色区域）3.形态学梯度： 是膨胀图和腐蚀图之差 （1）作用：将团块的边缘突出出来4.顶帽： 是原图和开运算的结果图之差 （1）作用：用来分离比邻近点亮一点的斑块5.黑帽： 是闭运算的结果图与原图之差 （1）作用：分离比邻近点暗一些的斑块（轮廓）五、漫水填充1.定义： 用特定颜色填充连通区域。 （1）用途：标记或分离图像一部分，以进一部处理；获得图像掩码区域2.函数： 六、图像金字塔与图片尺寸缩放1.引言： 对图片放大或者缩小 2.图像金字塔： 底部表示高分辨率，顶部表示低分辨率 （1）pyrUp()函数 （2）pyrDown()函数3.尺寸调整：resize()函数 专门调整图像大小的函数七、阈值化1.固定阈值操作：Threshold()函数 对单通道数组应用固定阈值操作 （1）用途：对灰度图像进行阈值操作得到二值图像或者去掉噪声。 2.自适应阈值操作：adaotiveThreshold()函数总结：将彩色变为灰度图赋值0到矩阵Mat temp=Scalar::all(0); 1.基于Opencv的边缘检测 创建时间：2017/11/19 9:52 更新时间：2017/11/20 16:25 作者：2568349595@qq.com 1.基于Opencv的边缘检测1、边缘检测的一般步聚： （1）滤波 （2）增强 （3）检测 2.canny算子 （1）目标是找到一个最优的边缘检测算法 （2）边缘检测步聚 消除噪声 计算梯度幅值和方向 非极大值抑制 滞后阈值 （3）Canny（）函数 3.sobel算子 （1）基本概念：主要用于检测边缘的离散微分算子。 （2）计算过程 分别在x和y两个方向求导 在图像中每一点，结合上面两个值求出近似梯度 （3）Sobel（）函数------可直接使用彩色图 4.Laplacian算子 （1）简介： （2）Laplacian（）函数 5.scharr滤波器 （1）Scharr()函数 2.霍夫变换1.概述： 使图像处理中的一种特征提取技术，从图像中识别几何形状的基本方法 霍夫线变换和霍夫圆变换2.霍夫线变换 步聚：（1）对图像进行边缘检测处理，（2）然后进行变换 三种霍夫变换：标准霍夫变换；多尺度霍夫变换；累计概率霍夫变换3.标准霍夫变换：HoughLines()函数4.累计概率霍夫变换：HoughLinesP()函数5.霍夫圆变换 6.霍夫梯度法原理 7.霍夫圆变换：HoughCircle()函数 3.重映射1、重映射概念： 就是把一幅图像中某个位置的像素放置另一个图像指定位置的过程 2.实现重映射：remap()函数 4.仿射变换​1.概念： 一个向量空间进行一次线性变换并接上一个平移，变换为另一个向量空间的过程。 保持二维图像的“平直性”和“平行性” （1）三种常见变换： 旋转（线性变换） 平移（向量加） 缩放（线性变换） 2.求法 3.进行仿射变换：warpAffine()函数 4.计算而为旋转变换矩阵：getRotationMatrix2D()函数 5.求得仿射变换 5.直方图均匀化​1.概念： 就是使用一定算法使得直方图大致平和的方法。应用于图像增强； 简而言之，拉伸像素强度分布范围来增强图像对比度的一种方法2.实现直方图均衡化：equalizeHist()函数 （1）步聚： 总结计算矩阵绝对值： convertScaleAbs(dst,abs_dst); 无标题笔记 创建时间：2017/11/20 16:27 更新时间：2017/11/20 16:31 作者：2568349595@qq.com 1.查找并绘制轮廓 创建时间：2017/11/20 16:33 更新时间：2017/11/20 20:23 作者：2568349595@qq.com 1.查找并绘制轮廓1.寻找轮廓：findContours()函数 用于函数在二值图像中寻找轮廓 2.绘制轮廓：drawCounters()函数 2.寻找物体的凸包1.凸包： 给定二维平面上的点集，凸包就是将最外层的点连接起来构成的凸多边形。 2.寻找凸包：convexHull()函数 3.使用多边形将轮廓包围1.​返回外部矩形边界：boundingRect()函数 2.寻找最小包围矩形：minAreaRect（）函数 3.寻找最小包围圆形：minEnclosingCircle()函数 4.用椭圆拟合二维点集：fitEllipse()函数 5.逼近多边形曲线：approxPolyDP函数 4.图像的距 （1）​距函数在图像分析中有着广泛的应用，如模拟识别、目标分类与方位估计、图像编码与重构 （2）一阶距与形状有关；二阶距显示曲线围绕直线平均值的扩展程度；三阶距关于平均值对称性的测量 （3）不变距使图像的统计特性，满足平移、伸缩、旋转均不变性1.距的计算：moments()函数 2.计算轮廓面积：contourArea()函数3.计算轮廓长度：arcLength()函数 五、分水岭算法​1.基本思想： 2.实现算法：watershed()函数六、图像修补​1.利用哪些已经损害的区域边缘，繁殖和混合到损坏的图像中，以达到图像修补的目的。2.inpaint()函数总结：​产生范围内的随机数（两个参数表示范围） 1.直方图的描述 创建时间：2017/11/21 9:30 更新时间：2017/11/21 10:38 作者：2568349595@qq.com 1.直方图的描述（1）意义： 直方图是图像中像素强度分布的图形表达式 它统计了每一个强度值所具有的像素个数2、直方图的计算与绘制1.计算直方图：calcHist()函数 2.寻找最值：minMaxLoc()函数 在数组中找到全局最小值和最大值 3.直方图对比​4.反向投影​1.引言： 就是先计算某一特征的直方图模型，然后去寻找图像中存在该特征的方法2.工作原理： 3.反向投影作用： 4.反向投影结果：calcBackProject()函数 5.通道复制：mixChannels(）函数 5、模版匹配​1.概念与原理 2.实现模板匹配：matchTemplate()函数 1.导读 创建时间：2017/11/21 15:57 更新时间：2017/11/21 20:00 作者：2568349595@qq.com 1.导读角点检测： 2.Harris角点jiance1.兴趣点与角点 兴趣点又称关键点、特征点。 （1）图像特征类型如下三类： 边缘、角点、斑点 角点：如果某一点在任意方向上的一个微小变动都会引起灰度值很大的变化，则称为角点。 角点的具体描述： 2.角点检测： （1）当前图像领域，分为三类： 基于灰度图像的角点检测 基于二值图像的角点检测 基于轮廓曲线的角点检测3.harris角点检测 4.实现harris角点检测：conerHarris()函数 2.Shi-Tomasi角点检测​1.确定图像强角点：goodFeaturesToTrack()函数3.亚像素级角点检测​1.寻找亚像素角点：cornerSubPix()函数 1.SURF特征点检测 创建时间：2017/11/21 20:06 更新时间：2017/11/21 22:31 作者：2568349595@qq.com 1.SURF特征点检测SURF算法原理: (1)构建海森矩阵构造高斯金字塔尺度空间 因为特征点需要具备尺度无关性，所以进行海森矩阵构造前进行高斯滤波； 2.利用非极大值抑制初步确定特征点 3.精确定位极值点 4.选取特征点的主方向 5.构造surf特征点描述算子绘制关键点：drawKeypoints()函数 KeyPoint类 2.SURF特征提取1.绘制匹配点：drawMatches()函数 形态学操作： 创建时间：2018/6/3 15:08 更新时间：2018/6/3 15:38 作者：2568349595@qq.com 来源：http://blog.sina.com.cn/s/blog_159aff7940102xdf4.html 形态学操作： 在图像处理技术中，有些会改变图像形态的操作称为形态学操作1.腐蚀操作 主要目的将物体的边缘腐蚀掉。 具体的操作方法是拿一个宽m,高n的矩形作为模板，对图像中的每一个像素x做如下处理：像素x至于模板的中心，根据模版的大小，遍历所有被模板覆盖的其他像素，修改像素x的值为所有像素中最小的值。这样操作的结果是会将图像外围的突出点加以腐蚀。如下图的操作过程：2、膨胀操作与腐蚀操作相反，是将图像的轮廓加以膨胀。操作方法与腐蚀操作类似，也是拿一个矩形模板，对图像的每个像素做遍历处理。不同之处在于修改像素的值不是所有像素中最小的值，而是最大的值。这样操作的结果会将图像外围的突出点连接并向外延伸。如下图的操作过程：3、闭操作作用：排除小型黑洞，突触了比原图轮廓区域更暗的区域，将两个区域连接起来，形成连通域。闭操作就是对图像先膨胀，再腐蚀。闭操作的结果一般是可以将许多靠近的图块相连称为一个无突起的连通域。在我们的图像定位中，使用了闭操作去连接所有的字符小图块，然后形成一个车牌的大致轮廓。闭操作的过程我会讲的细致一点。为了说明字符图块连接的过程。在这里选取的原图跟上面三个操作的原图不大一样，是一个由两个分开的图块组成的图。原图首先经过膨胀操作，将两个分开的图块结合起来（注意我用偏白的灰色图块表示由于膨胀操作而产生的新的白色）。接着通过腐蚀操作，将连通域的边缘和突起进行削平（注意我用偏黑的灰色图块表示由于腐蚀被侵蚀成黑色图块）。最后得到的是一个无突起的连通域（纯白的部分）。  ]]></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F07%2F19%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、总计基本都是第三种情况。 二、设计模式设计模式 1）策略模式属于对象行为模式,该模式可用于对于解决同一问题而采用不同方法的模式。 2）代理模式属于结构型模式，和策略模式相似。代理模式知道被代理人的函数，所以继承接口。 3）单例模式 3.1)线程安全部分代码注意 双检锁也是有问题。 3.2）应用场景任务管理器、回收站、日志应用、web应用的配置对象、数据库连接池、 总结：1、资源共享情况下，避免由于资源操作时导致的性能或损耗等 2、控制资源情况下，方便资源之间的相互通信。 4）工厂模式属于创建模式 5）观察者模式属于行为模式–类似于qt的信号与槽 6）组合模式整体与部分关系 7）迭代器模式 8)命令模式 9）门面模式1、为子系统中的一组接口提供一致界面，face定义了高层接口，这个接口使得子系统更加容易使用。将复杂逻辑封装起来，对外公布简单接口，由客户程序调用。 10）抽象工厂模式因为人的这些特性，这三种人都有而且 11）适配器模式将继承新的接口而包含老的接口。 12）模版模式模板模式是定义一个操作中的算法的骨架，而将一些步聚延迟到子类中。该类作用：可以使得子类可以不改变一个算法结构即可重定义该算法某些特定步聚。 13）建造者模式将复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示 14）桥梁模式将抽象与它的实现部分分离，使得他们都可以独立变化，实现分离就得增加一个类 15）装饰模式动态地给一个对象增加额外的职责装饰类即继承基类又包含基类。 15）职责链模式使得多个对象有机会处理请求，从而避免请求发送着和接受者之间耦合关系，将这些对象连城一条链，并沿着这条链传递该请求，直到一个对象处理它为止。 16）状态模式允许一个对象在其内部状态改变时改变它的行为。 17）访问者模式表示一个作用于某个对象结构中的各个元素的操作。]]></content>
      <categories>
        <category>-c++</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法]]></title>
    <url>%2F2018%2F07%2F18%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[贪心算法保证每次操作都是局部最优的，并且最后得到的结果是全局最优 1）分配饼干代码如下： 2)不重叠区间个数代码如下： 3）投飞镖刺气球类似于区间问题 4）种植花朵代码 5）判断是否是子序列 6）修改一个成为非递减数组 7）股票最大收益]]></content>
      <tags>
        <tag>c++</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目1_网络爬虫_单线程版本]]></title>
    <url>%2F2018%2F07%2F17%2F%E9%A1%B9%E7%9B%AE1_%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB_%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[一、基本框架（bfs） url地址分解 建立连接并获得资源 对资源解析获得图片url和其他链接url 图片下载 重复以上过程 二、详细解析过程1）url地址解析 –获得服务器地址和资源位置bool ParseUrl(const string url,string &amp;host,string &amp;resoure) url表示传入的网址 host为服务器的网址，resource为要得到的资源名 1.1)主要代码其中，const char* strstr(str1,str2)该函数将返回str2在str1的开头位置，如果没有返回NULL;strlen(str)返回str中字符个数，该函数必须字串以’\0’结尾，且字符计数不含有它；sscanf(src,”格式”，dst1,dst2)将字串按照一定格式将存入dst1和dst2中。2）建立连接并获得资源—–获得网页内容bool GetHtml(string&amp; host,string&amp; resource,char*&amp; data,long long size) host为主机地址，resource为资源位置 data为得到的html数据，size为获得响应数据大小 2.1）主要代码其中，struct hostent* gethostbyname(url)进行域名解析得到含有ip的结构体。注意 最后别忘了free(data),避免造成内存泄漏。2.2）http相关协议 由于该爬虫项目中只用到GET的请求，只是简单介绍相关内容请求资源 ：GET + “资源地址” +http版本信息\r\nhost: + “主机名”\r\nconnection: closed\r\n\r\n注意 结束处含有两个\r\n，表示请求头部信息结束 得到的响应响应：协议版本 + 200 + OK\r\n…\r\n\r\n + html内容注意 请求资源在\r\n\r\n 之后 其他http协议点击浏览。3）对资源解析—-获得图片url和其他链接url void ParseHtml(char* &amp;data); data为得到的响应内容。3.1）注意代码其中，使用到sprintf()和sscanf()函数相反使用。3.1）html编码内容 图片地址一般位于之中。 其他链接一般位于&lt;href=\” url \”&gt;之中。注意 为了防止存入的url地址不重复，我使用了数据库。如果没有预防的话可能无限死循环。4）图片下载 void Download(); 4.1)主要代码其中，使用了文件相关操作。 调用了ParseUrl和GetHtml函数 图片的内容保存在\r\n\r\n之后，且为二进制。 总结1） 了解广度遍历思想； 2） 回顾文件、网络、字串处理、MySQL、http、html等相关知识。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本语法]]></title>
    <url>%2F2018%2F07%2F17%2FMarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基本语法（0）特殊字符 （1）标题 # 表示标题等级1）大标题 在本行下面加 ==2）小标题 在本行下加 -- （2）加粗和倾斜文本 使用一对,在中间插入 文本使用两队**,在中间插入 （3）链接 （4）列表测试： &gt;应用 &gt;仍需要 &gt; 前面 （5）引用 （6）图片 （7） 换行 （8）分隔符 （9）小型文本 （10）注释 （11） 表格]]></content>
  </entry>
  <entry>
    <title><![CDATA[Markdown图片导入hexo问题]]></title>
    <url>%2F2018%2F07%2F17%2FMarkdown%E5%9B%BE%E7%89%87%E5%AF%BC%E5%85%A5hexo%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1 首先确认_config.yml 中有 post_asset_folder:true。Hexo 提供了一种更方便管理 Asset 的设定：post_asset_folder当您设置post_asset_folder为true参数后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。 2 在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image –save（需要等待一段时间）。3 完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。结构如下： 注意]]></content>
  </entry>
</search>
